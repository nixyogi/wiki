<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Personal Wiki</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Site for Personal wiki">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Linux Kernel</li><li class="chapter-item expanded "><a href="kernel/Kernel.html"><strong aria-hidden="true">1.</strong> Linux kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kernel/development/Development.html"><strong aria-hidden="true">1.1.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kernel/development/debugging/Debugging.html"><strong aria-hidden="true">1.1.1.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kernel/development/debugging/Debugging.html"><strong aria-hidden="true">1.1.1.1.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kernel/development/debugging/Dynamic-program-analysis.html"><strong aria-hidden="true">1.1.1.1.1.</strong> Dynamic Program Analysis</a></li><li class="chapter-item expanded "><a href="kernel/development/debugging/Fuzzing-Linux-Kernel.html"><strong aria-hidden="true">1.1.1.1.2.</strong> Fuzzing Linux Kernel</a></li><li class="chapter-item expanded "><a href="kernel/development/debugging/How-To-use-syzkaller.html"><strong aria-hidden="true">1.1.1.1.3.</strong> How to use syzkaller</a></li><li class="chapter-item expanded "><a href="kernel/development/debugging/Tools-and-Techniques-to-Debug-an-Linux-System.html"><strong aria-hidden="true">1.1.1.1.4.</strong> Tools-and-Techniques-to-Debug-an-Linux-System</a></li><li class="chapter-item expanded "><a href="kernel/development/debugging/Understanding-Linux-Kernel-Oops.html"><strong aria-hidden="true">1.1.1.1.5.</strong> Tools-and-Techniques-to-Debug-an-Linux-System</a></li></ol></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Personal Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-kernel"><a class="header" href="#linux-kernel">Linux Kernel</a></h1>
<p>This page is a placeholder, so that each folder has an page. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">Development</a></h1>
<p>This page is a placeholder, so that each folder has an page. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>This page is a placeholder, so that each folder has an page. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-1"><a class="header" href="#debugging-1">Debugging</a></h1>
<p>This page is a placeholder, so that each folder has an page. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-program-analysis"><a class="header" href="#dynamic-program-analysis">Dynamic Program analysis</a></h1>
<h2 id="what-is-dynamic-program-analysis-"><a class="header" href="#what-is-dynamic-program-analysis-">What is Dynamic program analysis ?</a></h2>
<p>It is analysis of the properties of a running program. The properties are </p>
<ol>
<li>Bugs </li>
<li>performance </li>
<li>code coverage</li>
<li>data flow </li>
</ol>
<p>These properties are valid for single execution </p>
<h2 id="what-is-static-program-analysis-"><a class="header" href="#what-is-static-program-analysis-">What is static program analysis ?</a></h2>
<p>It is analysis of properties of program code. 
These properties are valid for all execution. </p>
<h2 id="why-dynamic-program-analysis-is-better-than-static-"><a class="header" href="#why-dynamic-program-analysis-is-better-than-static-">Why Dynamic program analysis is better than static ?</a></h2>
<ol>
<li>
<p>Static program analysis is better for True positives, but it also generates
alot of false positives. </p>
</li>
<li>
<p>Dynamic program analysis is better to avoid false positives, hence the reports 
are more true positives than static. </p>
</li>
</ol>
<p>The problem with dynamic program analysis is that the coverage is not that good. </p>
<h2 id="diy-tools"><a class="header" href="#diy-tools">DIY Tools</a></h2>
<p>Kernel provides some tools for dynamic program analysis, 
Enable these configurations in the kernel config and kernel will analyse it for 
us. If anything fails then we get a bug report in the console. </p>
<ol>
<li>CONFIG_DEBUG_LIST=y , adds debug checks for link listss </li>
<li>CONFIG_FORTIFY_SOURCE=y, finds out of bounds access for simple codes </li>
<li>BUG_ON(condition) Check if your assumptions in code are true.</li>
<li>WARN_ON(condition) Check if your assumptions in code are true.</li>
<li>scrpits/decode_stacktrace.sh - this is usefull for finding line numbers 
from kernel oops. </li>
</ol>
<p>There are more configs which can be loaded full list is 
here - https://events.linuxfoundation.org/wp-content/uploads/2022/10/Dmitry-Vyukov-Dynamic-program-analysis_-LF-Mentorship.pdf (see page 23-25)</p>
<h2 id="kasan-kernel-address-sanatizer"><a class="header" href="#kasan-kernel-address-sanatizer">KASAN (Kernel Address Sanatizer)</a></h2>
<p>It is used to detect these type of bugs in the kernel </p>
<ul>
<li>Out-Of-Bounds</li>
<li>Use-After-Free</li>
<li>Heap, stack, globals</li>
</ul>
<p>It can be enabled in the kernel by setting config CONFIG_KASAN=y</p>
<h3 id="how-kasan-works-"><a class="header" href="#how-kasan-works-">How KASAN works ?</a></h3>
<ol>
<li>
<p>Shadow bytes
For every 8 bytes of kernel memory, it allocates 1 shadow byte. This shadow 
byte contains 0 if all bytes can be access (good bytes), 7 if 1 byte out of 8 bytes
cannot be accessed (bad byte) and -1 if all the bytes cannot be accessed. </p>
<p><img src="kernel/development/debugging/assets/shadow-byte.png" alt="quarantine" /></p>
<p>The shadow bytes are stored in a virtual memory section called KASAN shadow.</p>
</li>
<li>
<p>Red-zones around heap objects (to detect out-of-bound errors)</p>
<p><img src="kernel/development/debugging/assets/quarantine.png" alt="quarantine" /></p>
<p>If we try to access the redzones then bug is triggered. </p>
</li>
<li>
<p>Quarantine for heap objects (to detect Use-After-Free)</p>
<p>This delays the reuse of heap blocks, so if the kernel tries to access 
this block in quarantine then it is Use-After-Free bug. </p>
<p><img src="kernel/development/debugging/assets/quarantine.png" alt="quarantine" /></p>
</li>
<li>
<p>Compiler instrumentation: shadow check before memory access</p>
<p>Compiler adds a code check before any memory access which checks the shadow
byte is appropriate (i.e 0 for 8 byte access &amp; 4 for 4 byte access), 
if incorrect then it is a bug.</p>
</li>
</ol>
<p>This has an overhead, causing 2x slowdown and 2x more memory usage. </p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In kernel development, </p>
<ol>
<li>enable DEBUG_XXX, LOCKDEP, KASAN kernel configuration files</li>
<li>For new code, try to insert BUG_ON / WARN_ON</li>
<li>add/run kernel tests</li>
<li>Use scripts/decode_stacktrace.sh to debug </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuzzing-linux-kernel"><a class="header" href="#fuzzing-linux-kernel">Fuzzing Linux Kernel</a></h1>
<h2 id="what-is-fuzzing-"><a class="header" href="#what-is-fuzzing-">What is Fuzzing ?</a></h2>
<p>Feeding random inputs untill program crashes. </p>
<p><img src="kernel/development/debugging/assets/fuzzing-img.png" alt="fuzzing" /></p>
<p>for Fuzzing we need to answer these questions </p>
<ol>
<li>How do we execute the program ? </li>
<li>How do we inject inputs ?</li>
<li>How do we generate inputs ?</li>
<li>How do we detect program crashes ?</li>
<li>How do we automate the whole process ? </li>
</ol>
<p>except for #3 all others depend on the program that we are Fuzzing.</p>
<h2 id="how-do-we-generate-inputs-"><a class="header" href="#how-do-we-generate-inputs-">How do we generate inputs ?</a></h2>
<p>Just generating random data does not always work, </p>
<p>for example: if we are fuzzing an xml parser, the just to generate header 
<code>&lt;xml</code> it will take ~2^32 guesses. </p>
<p>So random data does not always work </p>
<p>So there are 3 approaches to generate better inputs </p>
<ol>
<li>Structured inputs (structure-aware-fuzzing)
<ul>
<li>We build a grammar for inputs and fuzz them. </li>
</ul>
</li>
<li>Guided generation (coverage-guided-fuzzing)
<img src="kernel/development/debugging/assets/guided-generation-fuzzing.png" alt="fuzzing" />
<ul>
<li>We use an existing pool of corpus input or a random input</li>
<li>We mutate (change) it </li>
<li>We use it as an input and execute the program</li>
<li>We check if covers new code ? 
<ul>
<li>If yes then we add it to Corpus inputs pool </li>
<li>else we start again from random input. </li>
</ul>
</li>
</ul>
</li>
<li>Collecting corpus samples and mutating them 
<ul>
<li>We can scrape the internet and collect inputs.</li>
<li>These inputs can be mutated and fed into the program. </li>
</ul>
</li>
</ol>
<p>These approaches can be combined with each other to create new inputs for fuzzing.</p>
<h2 id="kernel-fuzzing"><a class="header" href="#kernel-fuzzing">Kernel fuzzing</a></h2>
<h3 id="how-to-inject-inputs-to-kernel-"><a class="header" href="#how-to-inject-inputs-to-kernel-">How to inject inputs to kernel ?</a></h3>
<p>To inject inputs we need to understand what inputs does kernel have. </p>
<h4 id="what-kind-of-inputs-does-kernel-have"><a class="header" href="#what-kind-of-inputs-does-kernel-have">What kind of inputs does kernel have</a></h4>
<ol>
<li>
<p>syscalls
<img src="kernel/development/debugging/assets/kernel-inputs-syscall.png" alt="fuzzing" /></p>
<ul>
<li>We can use program which calls syscalls to inject syscall input.</li>
</ul>
</li>
<li>
<p>external inputs i.e usb dev, network packets, firmware etc. </p>
<p><img src="kernel/development/debugging/assets/kernel-inputs-external.png" alt="fuzzing" /></p>
<ul>
<li>
<p>We can use userspace or hypervisor/emulator to give external inputs</p>
<p>for ex: </p>
<ol>
<li>for usb we can use <code>/dev/raw-gadget</code> + Dummy UDC </li>
<li>for network we can use <code>/dev/tun</code></li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="how-to-generate-inputs-for-kernel-"><a class="header" href="#how-to-generate-inputs-for-kernel-">How to generate inputs for kernel ?</a></h3>
<p>Kernel does not accept data as inputs it accepts syscalls. </p>
<p>Most syscalls are used as API i.e </p>
<ul>
<li>It is always a sequence of calls </li>
<li>Argumets to the calls are structured </li>
<li>Return values or struct are used as inputs in next calls </li>
</ul>
<p>sequence of calls in the input to the kernel</p>
<p>API-aware fuzzing </p>
<ul>
<li>inputs are api call sequences </li>
<li>these are generated and mutated accordingly</li>
</ul>
<p>External inputs are also similar to API's. </p>
<p>So most common input structures are </p>
<ol>
<li>API </li>
<li>API with callbacks </li>
<li>Scripts </li>
<li>USB-like stuff</li>
</ol>
<h2 id="tools-used-for-fuzzing-the-kernel"><a class="header" href="#tools-used-for-fuzzing-the-kernel">Tools used for Fuzzing the kernel</a></h2>
<p>There are other tools but most common are </p>
<ol>
<li>Trinity - finds less bugs but easier to deploy</li>
<li>Syzkaller - goes deeper but finds more bugs and easier to extend</li>
</ol>
<h2 id="approaches-to-fuzzing-kernel"><a class="header" href="#approaches-to-fuzzing-kernel">Approaches to fuzzing kernel</a></h2>
<ul>
<li>Building kernel code as userspace program and fuzzing that
<ul>
<li>Works for code that is separable from kernel, but some kernel code 
cannot be separated.</li>
</ul>
</li>
<li>Reusing a userspace fuzzer
<ul>
<li>Works for fuzzing blob-like inputs, but most kernel inputs are not blobs</li>
</ul>
</li>
<li>Using syzkaller
<ul>
<li>Good for fuzzing kernel API </li>
</ul>
</li>
<li>Writing a fuzzer from scratch
<ul>
<li>Only benefits when the interface is not API-based.</li>
</ul>
</li>
</ul>
<h2 id="tips-for-using-syzkaller"><a class="header" href="#tips-for-using-syzkaller">Tips for using syzkaller</a></h2>
<ol>
<li>
<p>Don't just fuzz mainline with the default config</p>
<ul>
<li>fuzz with different configs</li>
<li>fuzz a small number of related syscalls 
i.e fuzz 3 or 4 syscall related to networking</li>
<li>Fuzz distro kernels</li>
</ul>
</li>
<li>
<p>Build your fuzzer on top of syzkaller, extend syzkaller rather than writing 
your own fuzzer. </p>
</li>
<li>
<p>Reuse parts of the syzkaller for your fuzzer. </p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-syzkaller"><a class="header" href="#how-to-use-syzkaller">How to use syzkaller</a></h1>
<p>Syzkaller is an unsupervised kernel fuzzer that uses both structured fuzzing &amp;
coverage-guided fuzzing techniques to apply fuzzing to kernel syscalls.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p><img src="kernel/development/debugging/" alt="manager" /></p>
<p>Manager controls the test system, spwans vm's with fuzzers inside them
which generate small programs which invoke syscalls. </p>
<p>VM's communication using RPC and log the coverage achieved and trace information
which is stored in the database. </p>
<h2 id="describing-syscalls"><a class="header" href="#describing-syscalls">Describing syscalls</a></h2>
<p>Syzkaller has a separate language for Describing syscalls. </p>
<p>For example: the open() syscall below</p>
<pre><code class="language-cpp">int open(const char *pathname, int flags, mode_t mode);
</code></pre>
<p>is described in syzkaller as: </p>
<pre><code class="language-sh">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) fd
</code></pre>
<ul>
<li>
<p><code>file ptr[in, filename]</code>: the first argument, called file, is an input pointer 
containing a filename string.</p>
</li>
<li>
<p><code>flags flags[open_flags]</code>: the flags argument is any of the flags defined at 
open_flags array open_flags = O_WRONLY, O_RDWR, O_APPEND, ...</p>
</li>
<li>
<p><code>mode flags[open_mode]</code>: mode argument is any of the flags defined at 
open_mode array open_mode = S_IRUSR, S_IWUSR, S_IXUSR, ...</p>
</li>
<li>
<p><code>fd</code>: the return value will be stored here, to be later used on other 
syscalls.</p>
<p>for example: </p>
<pre><code>read(fd fd, buf buffer[out], count len[buf])
write(fd fd, buf buffer[in], count len[buf])
</code></pre>
</li>
</ul>
<p>If instead of fd (file descriptior) we want to fuzz integer values from 0 to 500
then we use syntax <code>int64[0:500]</code></p>
<p>syzkaller provides generic descrption for <code>ioctl()</code></p>
<pre><code>ioctl(fd fd, cmd intptr, arg buffer[in])
</code></pre>
<p>and also provides specific ones like </p>
<pre><code>ioctl$DRM_IOCTL_VERSION(fd fd_dri, cmd const[DRM_IOCTL_VERSION], arg ptr[in, drm_version])
ioctl$VIDIOC_QUERYCAP(fd fd_video, cmd const[VIDIOC_QUERYCAP], arg ptr[out, v4l2_capability])
</code></pre>
<p>See the refernce below for more. </p>
<p>Ref: https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md</p>
<h2 id="setting-up-syzkaller"><a class="header" href="#setting-up-syzkaller">Setting up syzkaller</a></h2>
<p>Follow the steps given here to setup syzkaller - https://github.com/google/syzkaller/blob/master/docs/linux/setup.md</p>
<p>Tips for running syzkaller</p>
<ol>
<li>Use different defconfigs </li>
<li>Limit the syscalls to 3-4 chosen, by adding the below in config.config
<pre><code>&quot;enable_syscalls&quot;: [ &quot;ptrace&quot;, &quot;getpid&quot; ],
</code></pre>
</li>
</ol>
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools-and-techniques-to-debug-an-embedded-linux-system"><a class="header" href="#tools-and-techniques-to-debug-an-embedded-linux-system">Tools and Techniques to Debug an Embedded Linux System</a></h1>
<h2 id="process-of-debugging"><a class="header" href="#process-of-debugging">Process of debugging</a></h2>
<ol>
<li>Understand the problem.</li>
<li>Reproduce the problem.</li>
<li>Identify the root cause.</li>
<li>Apply the fix.</li>
<li>Test it. If fixed, celebrate! If not, go back to step 1.</li>
</ol>
<h2 id="types-of-problems-in-software"><a class="header" href="#types-of-problems-in-software">Types of problems in Software</a></h2>
<p>We can classify them into 5 major categories </p>
<ol>
<li>Crash. - Fatal exceptions</li>
<li>Lockup/Hang. - Race conditions, Deadlocks</li>
<li>Logic/implementation. - Logical errors</li>
<li>Resource leakage. - Memory leaks</li>
<li>(Lack of) performance. - Program is not performing as expected.</li>
</ol>
<h2 id="tools--techniques-available-for-developers-to-solve-these-problems"><a class="header" href="#tools--techniques-available-for-developers-to-solve-these-problems">Tools &amp; Techniques available for developers to solve these problems</a></h2>
<ol>
<li>Our brain (aka knowledge).</li>
<li>Post mortem analysis (logging analysis, memory dump analysis, etc).</li>
<li>Tracing/profiling (specialized logging).</li>
<li>Interactive debugging (eg: GDB).</li>
<li>Debugging frameworks (eg: Valgrind).</li>
</ol>
<h2 id="post-mortem-analysis"><a class="header" href="#post-mortem-analysis">Post mortem analysis</a></h2>
<p>This type of analysis is done using the information exported by the system i.e 
logs, memory dumps etc. </p>
<h3 id="for-kernel-crashes"><a class="header" href="#for-kernel-crashes">For Kernel Crashes</a></h3>
<h4 id="method1-addr2line"><a class="header" href="#method1-addr2line">Method1: addr2line</a></h4>
<ol>
<li>
<p>Get the address from the memory dump. address of the <code>pc</code> (program counter)
can be used to get the line where kernel crashed.</p>
<pre><code class="language-sh">[ 17.201436] PC is at storage_probe+0x60/0x1a0
[ 17.205810] LR is at storage_probe+0x48/0x1a0
[ 17.210175] pc : [&lt;c06a21cc&gt;] lr : [&lt;c06a21b4&gt;] psr: 60000013
</code></pre>
</li>
<li>
<p>You need the <code>vmlinux</code> file which is in ELF format with debug info </p>
<pre><code>file vmlinux
vmlinux: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, BuildID[sha1]
ca2de68ea4e39ca0f11e688a5e9ff0002a9b7733, with debug_info, not stripped
</code></pre>
</li>
<li>
<p>Run the addr2line command with these inputs </p>
<pre><code class="language-sh">addr2line -f -p -e vmlinux 0xc06a21cc
</code></pre>
<p>This will give you the line number where the kernel crashed. </p>
<p>for eg: </p>
<p>storage_probe at /opt/labs/ex/linux/drivers/usb/storage/usb.c:1118</p>
</li>
</ol>
<h4 id="method2-gdb-list"><a class="header" href="#method2-gdb-list">Method2: gdb list</a></h4>
<ol>
<li>
<p>Get the function name + offset from the memory dump.</p>
<pre><code class="language-sh">[ 17.201436] PC is at storage_probe+0x60/0x1a0
[ 17.205810] LR is at storage_probe+0x48/0x1a0
[ 17.210175] pc : [&lt;c06a21cc&gt;] lr : [&lt;c06a21b4&gt;] psr: 60000013
</code></pre>
<p>i.e <code>storage_probe+0x60</code></p>
</li>
<li>
<p>You need the <code>vmlinux</code> file which is in ELF format with debug info </p>
<pre><code>file vmlinux
vmlinux: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, BuildID[sha1]
ca2de68ea4e39ca0f11e688a5e9ff0002a9b7733, with debug_info, not stripped
</code></pre>
</li>
<li>
<p>Run gdb on the vmlinux file, inside gdb run the command </p>
<pre><code>(gdb) list *(storage_probe+0x60)
</code></pre>
<p>This will show you the line where the kernel crashed.</p>
</li>
</ol>
<h3 id="for-userspace-crashes"><a class="header" href="#for-userspace-crashes">For Userspace Crashes</a></h3>
<p>Use the core dump from the segfault to find the line at which the segfault
occurred.</p>
<ol>
<li>
<p>Set the system limits to unlimited</p>
<pre><code class="language-sh"># ulimit -c unlimited
</code></pre>
</li>
<li>
<p>Run the program untill it crashes, the crash will generate a file called
<code>core</code> which contains the core dump. </p>
</li>
<li>
<p>Run the gdb on the core file and the program with debug symbols</p>
<pre><code>gdb &lt;program-here&gt; -c core
</code></pre>
</li>
<li>
<p>In gdb run the command <code>list</code> to go to the line where the program crashed.</p>
<ul>
<li><code>p</code> to print the specific variables. </li>
</ul>
</li>
</ol>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p>Tracing is a special form of logging, where data about the state and execution of
a program (or the kernel) is collected and stored for runtime (or later) analysis.</p>
<p>Using print() or printk() statements to log the state and variables is also a 
form of tracing. </p>
<h3 id="for-kernel-crashes-1"><a class="header" href="#for-kernel-crashes-1">For kernel crashes</a></h3>
<ol>
<li>
<p>for kernel tracing we need to configure the kernel tracing options</p>
<pre><code>zcat /proc/config.gz | grep TRACER=y
CONFIG_NOP_TRACER=y
CONFIG_HAVE_FUNCTION_TRACER=y
CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
CONFIG_CONTEXT_SWITCH_TRACER=y
CONFIG_GENERIC_TRACER=y
CONFIG_FUNCTION_TRACER=y
CONFIG_FUNCTION_GRAPH_TRACER=y
CONFIG_STACK_TRACER=y
CONFIG_IRQSOFF_TRACER=y
CONFIG_SCHED_TRACER=y
CONFIG_HWLAT_TRACER=y
CONFIG_OSNOISE_TRACER=y
CONFIG_TIMERLAT_TRACER=y
</code></pre>
</li>
<li>
<p>Mount the tracefs into the fs </p>
<pre><code class="language-sh">mount -t tracefs tracefs /sys/kernel/tracing/
</code></pre>
</li>
<li>
<p>Record the traces of the function getting executed</p>
<pre><code>trace-cmd record -p function_graph -F &lt;module&gt;/&lt;sysfs trigger to a module&gt;
</code></pre>
</li>
<li>
<p>Generate the report of the tracing </p>
<pre><code>trace-cmd report &gt; trace.log
</code></pre>
</li>
<li>
<p>Examine the trace.log to see the traces of the function. </p>
</li>
</ol>
<p><strong>Note</strong>: This is dynamic tracing i.e the tracing is enabled at runtime as long 
as the kernel is compiled with the correct configuration. </p>
<h3 id="for-userspace-crashes-1"><a class="header" href="#for-userspace-crashes-1">For userspace crashes</a></h3>
<h4 id="method-1-strace"><a class="header" href="#method-1-strace">Method 1: strace</a></h4>
<p>Using strace we can trace all the system calls the program is running to debug
the program.</p>
<p>Run a userspace program with strace </p>
<pre><code># strace &lt;program&gt;
</code></pre>
<h4 id="method-2-uprobe"><a class="header" href="#method-2-uprobe">Method 2: Uprobe</a></h4>
<p>This is used to trace the functions in the program. </p>
<ol>
<li>
<p>Kernel needs to be configured with the below options </p>
<pre><code>zcat /proc/config.gz | grep CONFIG_UPROBE
CONFIG_UPROBES=y
CONFIG_UPROBE_EVENTS=y
</code></pre>
</li>
<li>
<p>Add the tracepoints to all the functions </p>
<pre><code class="language-sh"># for f in `perf probe -F -x &lt;program&gt;`; \
    do perf probe -q -x &lt;program&gt; $f; done
</code></pre>
</li>
<li>
<p>List the tracepoints to know the tracepoint names</p>
<pre><code># perf probe -l | tee
</code></pre>
</li>
<li>
<p>Run the application and capture the tracepoints. </p>
<pre><code># perf record -e &lt;tracepoint_name&gt;:* -aR -- &lt;program&gt; &lt;args&gt;
</code></pre>
</li>
<li>
<p>Run the command to parse the trace</p>
<pre><code>perf script | tee
</code></pre>
</li>
</ol>
<h2 id="interactive-debugging"><a class="header" href="#interactive-debugging">Interactive Debugging</a></h2>
<p>An interactive debugging tool allows us to interact with the application at runtime.
It can execute the code step-by-step, set breakpoints,
display information (variables, stack, etc), list function call history (backtrace), etc.</p>
<p>GDB is the go to tool for Interactive debugging. </p>
<h3 id="for-kernel-space"><a class="header" href="#for-kernel-space">For kernel space</a></h3>
<p><strong>Note</strong>: If running on embedded, you need a gdbserver running on the target device
and a gdb client on the host device. </p>
<ol>
<li>
<p>Enable KGDB in the kernel </p>
<pre><code># zcat /proc/config.gz | grep ^CONFIG_KGDB
CONFIG_KGDB=y
CONFIG_KGDB_HONOUR_BLOCKLIST=y
CONFIG_KGDB_SERIAL_CONSOLE=y
</code></pre>
<p>KGDB has registered serial console as the port for communication. But we 
can use kgdb/agent-proxy to forward text console over IP. </p>
<p>Details on how to connect can be found here - https://kernel.googlesource.com/pub/scm/utils/kernel/kgdb/agent-proxy/+/refs/heads/master/README.TXT</p>
</li>
<li>
<p>On target machine, Put the kernel in debugging mode </p>
<pre><code class="language-sh"># Enable the serial port for kgdb communication
# echo ttymxc0 &gt; /sys/module/kgdboc/parameters/kgdboc
# Put the kernel in debug mode
# echo g &gt; /proc/sysrq-trigger
</code></pre>
</li>
<li>
<p>On host machine, run gdb with the kernel ELF </p>
<pre><code> gdb vmlinux -tui
</code></pre>
<ul>
<li><code>-tui</code> option opens the TUI which shows the code and line number in gdb</li>
</ul>
</li>
<li>
<p>In gdb prompt, run the command to connect to the target machine</p>
<pre><code>(gdb) target remote localhost:5551
</code></pre>
</li>
<li>
<p>This will connect and open up the gdb for debugging, now you can set breakpoints
get backtraces using gdb commands. </p>
</li>
</ol>
<h3 id="for-userspace-crashes-2"><a class="header" href="#for-userspace-crashes-2">For userspace crashes</a></h3>
<p><strong>Note</strong>: If running on embedded, you need a gdbserver running on the target device
and a gdb client on the host device. </p>
<ol>
<li>
<p>Start the gdbserver, on target device</p>
<pre><code>gdbserver :1234 &lt;program&gt;
</code></pre>
</li>
<li>
<p>On the host device, run gdb with the program in ELF format </p>
<pre><code>gdb &lt;program&gt; -tui
</code></pre>
</li>
<li>
<p>In gdb prompt, connect to the target device </p>
<pre><code>(gdb) target remote &lt;IP&gt;:1234
</code></pre>
</li>
<li>
<p>Now we can set breakpoints and see the backtrace of the program running 
on the target machine.</p>
</li>
</ol>
<h2 id="debugging-frameworks"><a class="header" href="#debugging-frameworks">Debugging frameworks</a></h2>
<p>Collection of tools when used to debug linux systems are called debugging frameworks. </p>
<p>Kernel has several debugging frameworks to identify memory leaks,
lockups, etc (see the &quot;Kernel Hacking&quot; configuration menu)</p>
<p>In user space, there is Valgrind for debugging memory leaks, race conditions 
and profiling etc.</p>
<h3 id="for-kernel-crashes-2"><a class="header" href="#for-kernel-crashes-2">For kernel crashes</a></h3>
<ol>
<li>
<p>Enable the detections in the kernel configuration </p>
<pre><code># zcat /proc/config.gz | grep &quot;CONFIG_SOFTLOCKUP_DETECTOR\|CONFIG_DETECT_HUNG_TASK&quot;
CONFIG_SOFTLOCKUP_DETECTOR=y
CONFIG_DETECT_HUNG_TASK=y
</code></pre>
</li>
<li>
<p>Once enabled, when something hangs for 30s or more, kernel will throw an 
oops. </p>
</li>
<li>
<p>After this we can use the steps in post mortem analysis to debug. </p>
</li>
</ol>
<h3 id="for-userspace-crashes-3"><a class="header" href="#for-userspace-crashes-3">For userspace crashes</a></h3>
<p>We use valgring to check for memory leaks, profiling , etc</p>
<p>For eg: </p>
<pre><code>valgrind --leak-check=full &lt;program&gt;
</code></pre>
<p>This will check for leaks etc.. </p>
<h2 id="which-tool-to-use-while-debugging-"><a class="header" href="#which-tool-to-use-while-debugging-">Which tool to use while debugging ?</a></h2>
<p>This depends on what type of problem you are debugging.</p>
<p><img src="kernel/development/debugging/assets/which-tool-best-for-debugging.png" alt="summary2" /></p>
<h4 id="references"><a class="header" href="#references">References</a></h4>
<p>Ref: https://www.youtube.com/watch?v=Paf-1I7ZUTo </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-linux-kernel-oops"><a class="header" href="#understanding-linux-kernel-oops">Understanding Linux kernel Oops</a></h1>
<p>Kernel panic is when there is a fatal error from which the kernel cannot recover.
So it forces the system into controlled system hang/reboot.</p>
<p>There are 2 types of panics </p>
<ol>
<li>Hard panics (Aiee!)</li>
<li>Soft panics (Oops!)</li>
</ol>
<h2 id="oops"><a class="header" href="#oops">Oops</a></h2>
<p>On faulty code execution or when an exception occurs kernel throws Oops. </p>
<p>When Oops occurs it dumps the message on the console. Message contains the 
CPU registers &amp; the processor status of when the Oops occured. </p>
<p>The process that triggered the Oops gets killed ungracefully. There is a chance
that the system may not resume from the Oops.</p>
<h2 id="understanding-oops-dump"><a class="header" href="#understanding-oops-dump">Understanding Oops Dump</a></h2>
<p>We will be using the sample Oops dump below, this oops is generated from 
the kernel panic module from the Task of the mentorship.</p>
<pre><code>[   96.106469] panic_msg: loading out-of-tree module taints kernel.
[   96.106525] panic_msg: module verification failed: signature and/or required key missing - tainting kernel
[   96.106710] Panic module init.
[   96.106713] BUG: kernel NULL pointer dereference, address: 0000000000000001
[   96.106718] #PF: supervisor read access in kernel mode
[   96.106721] #PF: error_code(0x0000) - not-present page
[   96.106723] PGD 0 P4D 0
[   96.106728] Oops: 0000 [#1] SMP NOPTI
[   96.106732] CPU: 1 PID: 7403 Comm: insmod Kdump: loaded Tainted: G       	OE 	5.15.0-72-generic #79~20.04.1-Ubuntu
[   96.106737] Hardware name: ASUSTeK COMPUTER INC. ROG Zephyrus G14 GA401IH_GA401IH/GA401IH, BIOS GA401IH.212 03/14/2022
[   96.106740] RIP: 0010:panic_module_init+0x15/0x1000 [panic_msg]
[   96.106749] Code: Unable to access opcode bytes at RIP 0xffffffffc1470feb.
[   96.106752] RSP: 0018:ffffaa368299bbb8 EFLAGS: 00010246
[   96.106755] RAX: 0000000000000012 RBX: 0000000000000000 RCX: 0000000000000027
[   96.106758] RDX: 0000000000000000 RSI: ffffaa368299ba00 RDI: ffff88d4d7460588
[   96.106761] RBP: ffffaa368299bbb8 R08: ffff88d4d7460580 R09: 0000000000000001
[   96.106763] R10: 696e6920656c7564 R11: 6f6d2063696e6150 R12: ffffffffc1471000
[   96.106766] R13: ffff88cfd734d390 R14: 0000000000000000 R15: ffffffffc1884000
[   96.106768] FS:  00007f241ee73740(0000) GS:ffff88d4d7440000(0000) knlGS:0000000000000000
[   96.106772] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   96.106775] CR2: ffffffffc1470feb CR3: 000000023ecac000 CR4: 0000000000350ee0
[   96.106778] Call Trace:
[   96.106780]  &lt;TASK&gt;
[   96.106784]  do_one_initcall+0x48/0x1e0
[   96.106791]  ? __cond_resched+0x19/0x40
[   96.106797]  ? kmem_cache_alloc_trace+0x15a/0x420
[   96.106804]  do_init_module+0x52/0x230
[   96.106810]  load_module+0x1294/0x1500
[   96.106819]  __do_sys_finit_module+0xbf/0x120
[   96.106823]  ? __do_sys_finit_module+0xbf/0x120
[   96.106830]  __x64_sys_finit_module+0x1a/0x20
[   96.106835]  do_syscall_64+0x5c/0xc0
[   96.106840]  ? exit_to_user_mode_prepare+0x3d/0x1c0
[   96.106845]  ? syscall_exit_to_user_mode+0x27/0x50
[   96.106849]  ? __x64_sys_mmap+0x33/0x50
[   96.106853]  ? do_syscall_64+0x69/0xc0
[   96.106857]  ? syscall_exit_to_user_mode+0x27/0x50
[   96.106861]  ? __x64_sys_read+0x1a/0x20
[   96.106865]  ? do_syscall_64+0x69/0xc0
[   96.106870]  ? irqentry_exit+0x1d/0x30
[   96.106874]  ? exc_page_fault+0x89/0x170
[   96.106879]  entry_SYSCALL_64_after_hwframe+0x61/0xcb
[   96.106885] RIP: 0033:0x7f241efa0a3d
[   96.106889] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d c3 a3 0f 00 f7 d8 64 89 01 48
[   96.106894] RSP: 002b:00007ffdbfab5128 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
[   96.106899] RAX: ffffffffffffffda RBX: 000055fd2f8b4780 RCX: 00007f241efa0a3d
[   96.106903] RDX: 0000000000000000 RSI: 000055fd2e243358 RDI: 0000000000000003
[   96.106906] RBP: 0000000000000000 R08: 0000000000000000 R09: 00007f241f0a3180
[   96.106909] R10: 0000000000000003 R11: 0000000000000246 R12: 000055fd2e243358
[   96.106912] R13: 0000000000000000 R14: 000055fd2f8b7b40 R15: 0000000000000000
[   96.106918]  &lt;/TASK&gt;
</code></pre>
<p>Let's try to understand the Oops dump.</p>
<ol>
<li>
<p><code>BUG: kernel NULL pointer dereference, address: 0000000000000001</code></p>
<ul>
<li>This indicates why the kernel crashed i.e it was because of NULL pointer
dereference. </li>
</ul>
</li>
<li>
<p><code>IP:</code></p>
<ul>
<li>IP shows the address of the instruction pointer. 
The above dump does not have IP. So in some cases IP maybe missing.</li>
</ul>
</li>
<li>
<p><code>Oops: 0000 [#1] SMP NOPTI</code></p>
<ul>
<li>
<p><code>0000</code> - is the error code value in Hex , where </p>
<ol>
<li>bit 0 - 0 means no page found, 1 means protection fault </li>
<li>bit 1 - 0 means read, 1 means write</li>
<li>bit 2 - 0 means kernelspace, 1 means userspace</li>
</ol>
<p>The above code denotes that while reading there was no page found in 
kerenelspace i.e NULL pointer dereference.</p>
</li>
<li>
<p><code>[#1]</code> - Number of Oops occured. There can be multiple Oops as cascading
effect. 1 Oops occured.</p>
</li>
</ul>
</li>
<li>
<p><code>CPU: 1 PID: 7403 Comm: insmod Kdump: loaded Tainted: G</code></p>
<ul>
<li>
<p><code>CPU 1</code> - Which CPU the error occured</p>
</li>
<li>
<p><code>Tainted: G</code> - Tainted flag</p>
<ol>
<li>P, G — Proprietary module has been loaded.</li>
<li>F — Module has been forcibly loaded.</li>
<li>S — SMP with a CPU not designed for SMP.</li>
<li>R — User forced a module unload.</li>
<li>M — System experienced a machine check exception.</li>
<li>B — System has hit bad_page.</li>
<li>U — Userspace-defined naughtiness.</li>
<li>A — ACPI table overridden.</li>
<li>W — Taint on warning.</li>
</ol>
<p>Ref: https://github.com/torvalds/linux/blob/master/kernel/panic.c</p>
<p>This shows that the proprietary module has been loaded. </p>
</li>
</ul>
</li>
<li>
<p><code>RIP: 0010:panic_module_init+0x15/0x1000 [panic_msg]</code></p>
<ul>
<li><code>RIP</code> - CPU register containing addr of the instruction getting executed. </li>
<li><code>0010</code> - Code segment register value. </li>
<li><code>panic_module_init+0x15/0x1000</code> - <symbol> + offset/ length</li>
</ul>
</li>
<li>
<p>CPU register contents</p>
<pre><code>RSP: 0018:ffffaa368299bbb8 EFLAGS: 00010246
RAX: 0000000000000012 RBX: 0000000000000000 RCX: 0000000000000027
RDX: 0000000000000000 RSI: ffffaa368299ba00 RDI: ffff88d4d7460588
RBP: ffffaa368299bbb8 R08: ffff88d4d7460580 R09: 0000000000000001
R10: 696e6920656c7564 R11: 6f6d2063696e6150 R12: ffffffffc1471000
R13: ffff88cfd734d390 R14: 0000000000000000 R15: ffffffffc1884000
FS:  00007f241ee73740(0000) GS:ffff88d4d7440000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: ffffffffc1470feb CR3: 000000023ecac000 CR4: 0000000000350ee0
</code></pre>
</li>
<li>
<p><code>Stack:</code> - This is the stack trace. </p>
<ul>
<li>But as you can see it is missing from the dump. This might be because 
the kernel is not configured correctly, but I am currently unable 
to get the exact config which enables stack.</li>
</ul>
</li>
<li>
<p><code>Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff  ff 73 01 c3 48 8b 0d c3 a3 0f 00 f7 d8 64 89 01 48</code></p>
<ul>
<li>This is a hex-dump of the section of machine code that was being run 
at the time the Oops occurred.</li>
</ul>
</li>
</ol>
<h2 id="debugging-the-oops"><a class="header" href="#debugging-the-oops">Debugging the Oops</a></h2>
<p>The aim here is to find out the Address where the Oops occured, so that 
we can use GDB to get the exact line of the code where the kernel Oops occured.</p>
<h3 id="method-1-using-the-oops-dump--gdb"><a class="header" href="#method-1-using-the-oops-dump--gdb">Method 1: Using the Oops dump + GDB</a></h3>
<h4 id="logic-behind-this-method"><a class="header" href="#logic-behind-this-method">Logic behind this method</a></h4>
<ol>
<li>RIP/PC - Instruction pointer or Program counter will give the instruction address
and offset. Addresss + offset = Instruction Addr where Oops occured. </li>
<li>Use GDB to dissassemble the function (this we get in the RIP line of Oops dump)</li>
<li>Once we get the address then use GDB <code>list</code> to get to the line of the code.</li>
</ol>
<h4 id="steps"><a class="header" href="#steps">Steps:</a></h4>
<ol>
<li>Load the module in GDB </li>
<li>Add the symbol-file in GDB </li>
<li>Disassemble the function mentioned in the <code>RIP</code> section in the above dump. </li>
<li>To get the exact line we use (RIP instruction addr + offset)</li>
<li>Then we run list *(RIP instruction addr + offest) to give the offending code. </li>
</ol>
<p>Honestly this method seems to be a bit complex, a simpler way would be to use
<code>addr2line</code> to convert the address to line. For more see the video </p>
<ul>
<li>https://youtu.be/X5uygywNcPI?t=1159</li>
</ul>
<h3 id="method-2-using-systemmap--gdb"><a class="header" href="#method-2-using-systemmap--gdb">Method 2: Using System.map + GDB</a></h3>
<p>System.map is the list of symbols and their addr in the kernel.</p>
<h4 id="logic-behind-this-method-1"><a class="header" href="#logic-behind-this-method-1">Logic behind this method</a></h4>
<ol>
<li>Using the function name from the Oops dump, get the symbol address from the
System.map. we call it Fun_Addr</li>
<li>Get the exact instruction address by Fun_Addr + Offset (from oops dump) </li>
<li>Dissassemble the function to get to the exact instruction where it failed.</li>
<li>To get to the line number use GDB <code>list</code> &amp; pass it Fun_Addr + Offset.</li>
</ol>
<h4 id="steps-1"><a class="header" href="#steps-1">Steps</a></h4>
<ol>
<li>Identify the PC/RIP (Addr &amp; offset) from the Oops dump.</li>
<li>Identify the function where the Oops occured from the Oops dump. </li>
<li>Get the exact instruction address by Fun_Addr + Offset (from oops dump) </li>
<li>Dissassemble the function to get to the exact instruction where it failed.</li>
<li>To get to the line number use GDB <code>list</code> &amp; pass it Fun_Addr + Offset.</li>
</ol>
<h2 id="ways-of-dissassembling"><a class="header" href="#ways-of-dissassembling">Ways of Dissassembling</a></h2>
<ol>
<li>Using <code>objdump</code></li>
<li>Using <code>gdb</code></li>
</ol>
<h4 id="objdump"><a class="header" href="#objdump">objdump</a></h4>
<pre><code>objdump -D -S --show-raw-insn --prefix-addresses --line-numbers vmlinux 
</code></pre>
<h4 id="gdb"><a class="header" href="#gdb">gdb</a></h4>
<pre><code class="language-sh"># Run gdb
gdb –silent vmlinux
# Inside gdb run the command 
dissassemble &lt;function-name&gt;
</code></pre>
<h2 id="tldr-summary"><a class="header" href="#tldr-summary">TLDR; Summary</a></h2>
<p><img src="kernel/development/debugging/assets/kernedebug.drawio.png" alt="summary1" /></p>
<h4 id="references-1"><a class="header" href="#references-1">References</a></h4>
<p>Ref: https://www.opensourceforu.com/2011/01/understanding-a-kernel-oops/
Ref: https://sanjeev1sharma.wordpress.com/tag/debug-kernel-panics/</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
